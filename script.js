// Яким буде результат його виклику? Чому? Опишіть як працює цей код. 
console.log('start');

const promise1 = new Promise((resolve, reject) => {
console.log(1)
resolve(2)
})

promise1.then(res => {
console.log(res)
})

console.log('end');

// спочатку відбулося виконання коду з console.log('start');,
//  потім створився новий об'єкт Promise - promise1, і відбулося виконання функції, яку ми передали як параметр у конструктор Promise. 
// У цій функції спочатку вивелось на консоль 1, 
// Нарешті, вивелось на консоль 'end', оскільки це було останнім рядком коду.
// а потім було викликано функцію resolve з параметром 2. 
// Це означає, що Promise був виконаний і значення 2 було передано як результат. Далі було викликано метод then на promise1, який дозволяє додати обробник для результату Promise.
//  У цьому обробнику ми просто вивели на консоль отриманий результат - 2. 


// 2 task

// Promise.resolve(1)
// 		.then((x) => x + 1)
// 		.then((x) => { throw new Error('My Error') })
// 		.catch(() => 1)
// 		.then((x) => x + 1)
// 		.then((x) => console.log(x))
// 		.catch(console.error)


        // Результатом виклику буде виведення на консоль числа 2. 

// При виклику Promise.resolve(1) створюється новий Promise, який повертає значення 1. 
// Потім за допомогою методу then до цього значення додається 1, тобто отримуємо 2. 
// Далі викликається метод then з функцією, яка генерує помилку. Це призведе до переходу до методу catch, який поверне значення 1. 
// Далі знову викликається метод then, до отриманого значення 1 додається 1, і отримуємо 2. 
// Нарешті, викликається метод then з функцією console.log, яка виводить на консоль отримане значення - 2. 

// Метод catch в даному випадку є обробником помилок, який перехоплює помилки, що виникають при виконанні попередніх методів then. 
// У даному випадку цей метод повертає значення 1, що дозволяє продовжити ланцюжок методів then.


// 3 task

// const promise = new Promise(res => res(2));
// 	promise.then(v => {
// 	        console.log(v);
// 	        return v * 2;
// 	    })
// 	    .then(v => {
// 	        console.log(v);
// 	        return v * 2;
// 	    })
// 	    .finally(v => {
// 	        console.log(v);
// 	        return v * 2;
// 	    })
// 	    .then(v => {
// 	        console.log(v);
// 	    });


        // При створенні нового promise за допомогою конструктора Promise передається функція-виконавець,
        //  яка повертає значення 2. 
        // Потім до цього значення за допомогою методу then додається 2, тобто отримуємо 4. 
        // Потім знову за допомогою методу then до отриманого значення додається 2 і отримується 8. 

// Метод finally не приймає значення і не впливає на ланцюжок методів then. 
// В даному випадку він просто виводить на консоль undefined. 

// Останній метод then отримує значення 8 і виводить його на консоль. 

// Отже, результатом виклику є послідовне виведення на консоль чисел 2, 4, undefined, 8.
